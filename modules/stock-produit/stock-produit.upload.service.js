// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë                     STOCK-PRODUIT.UPLOAD.SERVICE.JS                        ‚ïë
// ‚ïë                      Service Import/Analyse CSV                            ‚ïë
// ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
// ‚ïë Module: Import CSV avec d√©tection automatique colonnes                     ‚ïë
// ‚ïë Version: 1.0.0                                                             ‚ïë
// ‚ïë Date: 03/02/2025                                                           ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë     SECTION 1: CONFIGURATION           ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

const CONFIG = {
    maxFileSize: 10 * 1024 * 1024, // 10MB
    allowedTypes: ['text/csv', 'application/vnd.ms-excel', 'text/plain'],
    allowedExtensions: ['.csv', '.txt', '.tsv'],
    
    // ‚îÄ‚îÄ‚îÄ MAPPING COLONNES CSV ‚Üí FIREBASE ‚îÄ‚îÄ‚îÄ
    COLUMN_MAPPINGS: {
        // CSV ‚Üí Firebase
        marque: ['marque', 'brand', 'fabricant'],
        libelle: ['libelle', 'libell√©', 'description', 'nom'],
        numeroSerie: ['numero_de_serie', 'num_serie', 'n_serie', 'serie', 'serial'],
        magasin: ['centre', 'magasin', 'lieu', 'site'],
        statut: ['etat', '√©tat', 'statut', 'status'],
        quantite: ['qte', 'quantite', 'quantit√©', 'qty', 'stock'],
        client: ['client', 'customer', 'destinataire'],
        fournisseur: ['fournisseur', 'supplier', 'vendor'],
        date: ['date', 'date_edition', 'date_√©dition', 'date_creation']
    }
};

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë   SECTION 2: SERVICE UPLOAD            ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

class StockProduitUploadService {
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      ANALYSE FICHIER CSV               ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
async analyserCSV(file) {
    try {
        console.log('üìä Analyse du fichier:', file.name);
        
        // Validation fichier
        this.validateFile(file);
        
        // Lecture fichier
        const content = await this.readFileWithEncoding(file);
        const lines = content.split(/\r?\n/).filter(line => line.trim());
        
        if (lines.length === 0) {
            throw new Error('Fichier vide');
        }
        
        // Trouver la ligne avec les colonnes (celle qui contient "Marque", "Libell√©", etc.)
        let headerLineIndex = -1;
        let separator = ';';
        
        for (let i = 0; i < Math.min(lines.length, 20); i++) {
            const line = lines[i].toLowerCase();
            if (line.includes('marque') && line.includes('libell√©')) {
                headerLineIndex = i;
                console.log(`‚úÖ Headers trouv√©s ligne ${i}: ${lines[i]}`);
                break;
            }
        }
        
        if (headerLineIndex === -1) {
            throw new Error('Colonnes non trouv√©es');
        }
        
        // Parser les colonnes
        const headerLine = lines[headerLineIndex];
        const headers = headerLine.split(separator).map(h => h.replace(/"/g, '').trim());
        
        console.log('üìã COLONNES:', headers);
        
        // MAPPING DIRECT DES INDEX
        const mapping = {};
        headers.forEach((header, index) => {
            const h = header.toLowerCase();
            if (h === 'date') mapping.date = index;
            else if (h === 'marque') mapping.marque = index;
            else if (h === 'libell√©') mapping.libelle = index;
            else if (h === 'n¬∞ s√©rie') mapping.numeroSerie = index;
            else if (h === 'centre') mapping.magasin = index;
            else if (h === '√©tat') mapping.statut = index;
            else if (h === 'qt√©') mapping.quantite = index;
            else if (h === 'client') mapping.client = index;
            else if (h === 'fournisseur') mapping.fournisseur = index;
        });
        
        console.log('üìç MAPPING:', mapping);
        
        // Parser les articles
        const articles = [];
        
        for (let i = headerLineIndex + 1; i < lines.length; i++) {
            const line = lines[i];
            if (!line.trim()) continue;
            
            const values = line.split(separator).map(v => v.replace(/"/g, '').trim());
            
            const article = {
                date: values[mapping.date] || '-',
                marque: values[mapping.marque] || '-',
                libelle: values[mapping.libelle] || '-',
                numeroSerie: values[mapping.numeroSerie] || null,
                magasin: values[mapping.magasin] || '-',
                statut: values[mapping.statut] || 'STO',
                quantite: parseInt(values[mapping.quantite]) || 0,
                client: values[mapping.client] || '-',
                fournisseur: values[mapping.fournisseur] || '-'
            };
            
            // Convertir la date DD/MM/YYYY en YYYY-MM-DD
            if (article.date && article.date !== '-') {
                const match = article.date.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                if (match) {
                    const [, day, month, year] = match;
                    article.date = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                }
            }
            
            // Ne pas ajouter les lignes vides
            if (article.libelle !== '-' || article.numeroSerie) {
                articles.push(article);
                console.log(`‚úÖ Article ${i}: Date=${article.date}, S√©rie=${article.numeroSerie}`);
            }
        }
        
        console.log(`‚úÖ ${articles.length} articles extraits`);
        
        return {
            articles,
            stats: {
                total: articles.length,
                quantiteTotale: articles.reduce((sum, a) => sum + a.quantite, 0)
            },
            errors: [],
            mapping: mapping,
            separator: separator
        };
        
    } catch (error) {
        console.error('‚ùå Erreur:', error);
        throw error;
    }
}
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      VALIDATION FICHIER                ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    validateFile(file) {
        // ‚îÄ‚îÄ‚îÄ V√©rification taille ‚îÄ‚îÄ‚îÄ
        if (file.size > CONFIG.maxFileSize) {
            const sizeMB = (CONFIG.maxFileSize / 1024 / 1024).toFixed(0);
            throw new Error(`Fichier trop volumineux (max ${sizeMB}MB)`);
        }
        
        // ‚îÄ‚îÄ‚îÄ V√©rification type ‚îÄ‚îÄ‚îÄ
        const extension = '.' + this.getFileExtension(file.name);
        const typeValide = CONFIG.allowedTypes.includes(file.type) || 
                          CONFIG.allowedExtensions.includes(extension.toLowerCase());
        
        if (!typeValide) {
            throw new Error(`Type de fichier non autoris√©. Formats accept√©s: CSV, TXT`);
        }
    }
    
    getFileExtension(filename) {
        const parts = filename.split('.');
        return parts.length > 1 ? parts.pop().toLowerCase() : 'csv';
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      D√âTECTION S√âPARATEUR              ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    detectSeparator(content) {
        const firstLines = content.split(/\r?\n/).slice(0, 5).join('\n');
        const separators = [';', ',', '\t', '|'];
        let maxCount = 0;
        let bestSeparator = ';';
        let maxConsistency = 0;
        
        for (const sep of separators) {
            const regex = sep === '\t' ? /\t/g : new RegExp('\\' + sep, 'g');
            const lines = firstLines.split(/\r?\n/);
            const counts = [];
            
            // ‚îÄ‚îÄ‚îÄ Compter s√©parateur dans chaque ligne ‚îÄ‚îÄ‚îÄ
            for (const line of lines) {
                if (line.trim()) {
                    const matches = line.match(regex);
                    counts.push(matches ? matches.length : 0);
                }
            }
            
            // ‚îÄ‚îÄ‚îÄ V√©rifier coh√©rence ‚îÄ‚îÄ‚îÄ
            if (counts.length > 0) {
                const avgCount = counts.reduce((a, b) => a + b, 0) / counts.length;
                const consistency = counts.every(c => c === counts[0]) ? 1 : 0;
                
                // Pr√©f√©rer le s√©parateur avec plus de colonnes ET meilleure coh√©rence
                if (avgCount > maxCount || (avgCount === maxCount && consistency > maxConsistency)) {
                    maxCount = avgCount;
                    maxConsistency = consistency;
                    bestSeparator = sep;
                }
            }
        }
        
        console.log(`üìå S√©parateur d√©tect√©: "${bestSeparator}" avec ${maxCount} colonnes`);
        return bestSeparator;
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      D√âTECTION MAPPING COLONNES        ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
// REMPLACER la fonction detectColumns COMPL√àTE
parseArticle(line, separator, columnMapping) {
    const values = this.parseCSVLine(line, separator);
    
    // DEBUG: AFFICHER LES VALEURS
    console.log('üìù Ligne CSV:', line);
    console.log('üìä Valeurs pars√©es:', values);
    console.log('üó∫Ô∏è Mapping:', columnMapping);
    
    const article = {};
    let hasData = false;
    
    for (const [index, field] of Object.entries(columnMapping)) {
        const value = values[parseInt(index)];
        
        // DEBUG SP√âCIFIQUE POUR LA DATE
        if (field === 'date') {
            console.log(`üìÖ COLONNE DATE - Index ${index}: "${value}"`);
        }
        
        if (value && value.trim()) {
            hasData = true;
            
            switch (field) {
                case 'date':
                    article.date = this.parseDate(value) || value || '-';
                    console.log(`üìÖ DATE FINALE: "${article.date}"`);
                    break;
                    
                case 'quantite':
                    article.quantite = this.parseNumber(value, true);
                    break;
                    
                case 'marque':
                    article.marque = this.cleanString(value);
                    break;
                    
                case 'libelle':
                    article.libelle = this.cleanString(value);
                    break;
                    
                case 'numeroSerie':
                    article.numeroSerie = this.cleanString(value);
                    break;
                    
                case 'magasin':
                    article.magasin = this.cleanString(value);
                    break;
                    
                case 'client':
                    article.client = this.cleanString(value);
                    break;
                    
                case 'fournisseur':
                    article.fournisseur = this.cleanString(value);
                    break;
                    
                case 'statut':
                    article.statut = this.cleanString(value).toUpperCase();
                    break;
                    
                default:
                    article[field] = this.cleanString(value);
            }
        }
    }
    
    // Valeurs par d√©faut
    article.quantite = article.quantite || 0;
    article.statut = article.statut || 'STO';
    article.date = article.date || '-';
    
    console.log('‚úÖ ARTICLE COMPLET:', article);
    
    return hasData ? article : null;
}
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      PARSING ARTICLE                   ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
// REMPLACER la fonction parseArticle COMPL√àTE
parseArticle(line, separator, columnMapping) {
    const values = line.split(separator).map(v => v.trim());
    
    console.log('üìù Valeurs de la ligne:', values);
    
    const article = {};
    let hasData = false;
    
    for (const [index, field] of Object.entries(columnMapping)) {
        const value = values[parseInt(index)];
        
        if (field === 'date') {
            // PARSER LA DATE DE CETTE LIGNE
            if (value && value !== '') {
                // Convertir DD/MM/YYYY en YYYY-MM-DD
                const match = value.match(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})/);
                if (match) {
                    const [, day, month, year] = match;
                    const fullYear = year.length === 2 ? '20' + year : year;
                    article.date = `${fullYear}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                    console.log(`üìÖ DATE PARS√âE: ${value} ‚Üí ${article.date}`);
                } else {
                    article.date = value; // Garder la valeur originale
                }
            } else {
                article.date = '-';
            }
        }
        else if (value && value.trim()) {
            hasData = true;
            
            switch (field) {
                case 'quantite':
                    article.quantite = parseInt(value) || 0;
                    break;
                case 'marque':
                    article.marque = value;
                    break;
                case 'libelle':
                    article.libelle = value;
                    break;
                case 'numeroSerie':
                    article.numeroSerie = value;
                    break;
                case 'magasin':
                    article.magasin = value;
                    break;
                case 'client':
                    article.client = value;
                    break;
                case 'statut':
                    article.statut = value.toUpperCase();
                    break;
                default:
                    article[field] = value;
            }
        }
    }
    
    // Valeurs par d√©faut
    if (!article.date) article.date = '-';
    if (!article.quantite) article.quantite = 0;
    if (!article.statut) article.statut = 'STO';
    
    console.log('‚úÖ ARTICLE FINAL AVEC DATE:', article);
    
    return hasData ? article : null;
}
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      PARSING LIGNE CSV                 ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    parseCSVLine(line, separator) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            const nextChar = line[i + 1];
            
            if (char === '"') {
                if (inQuotes && nextChar === '"') {
                    current += '"';
                    i++; // Skip next quote
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === separator && !inQuotes) {
                result.push(current);
                current = '';
            } else {
                current += char;
            }
        }
        
        result.push(current); // Derni√®re valeur
        
        return result.map(v => v.trim().replace(/^["']|["']$/g, ''));
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      PARSING NOMBRES                   ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    parseNumber(value, isInteger = false) {
        if (!value || value === '') return 0;
        
        let cleaned = value.toString()
            .replace(/\s/g, '')
            .trim();
        
        // ‚îÄ‚îÄ‚îÄ G√©rer nombres n√©gatifs entre parenth√®ses ‚îÄ‚îÄ‚îÄ
        if (cleaned.startsWith('(') && cleaned.endsWith(')')) {
            cleaned = '-' + cleaned.slice(1, -1);
        }
        
        // ‚îÄ‚îÄ‚îÄ Format fran√ßais (virgule comme d√©cimale) ‚îÄ‚îÄ‚îÄ
        if (cleaned.includes(',')) {
            cleaned = cleaned.replace(/\./g, '').replace(',', '.');
        }
        
        const parsed = parseFloat(cleaned);
        if (isNaN(parsed)) return 0;
        
        return isInteger ? Math.round(parsed) : parsed;
    }
    
    parseMontant(value) {
        if (!value || value === '') return 0;
        
        let cleaned = value.toString()
            .replace(/\s/g, '')
            .replace(/[‚Ç¨$¬£]/g, '')
            .replace(/EUR|USD|GBP/gi, '')
            .trim();
        
        if (!cleaned) return 0;
        
        // ‚îÄ‚îÄ‚îÄ Format fran√ßais ‚îÄ‚îÄ‚îÄ
        if (cleaned.includes(',')) {
            const commaCount = (cleaned.match(/,/g) || []).length;
            const dotCount = (cleaned.match(/\./g) || []).length;
            
            if (commaCount === 1 && dotCount === 0) {
                cleaned = cleaned.replace(',', '.');
            } else if (dotCount > 0) {
                cleaned = cleaned.replace(/\./g, '').replace(',', '.');
            }
        }
        
        const parsed = parseFloat(cleaned);
        return isNaN(parsed) ? 0 : Math.abs(parsed);
    }
    
    parseDate(value) {
        if (!value || value === '') return '-';
        
        const cleaned = value.trim();
        
        // ‚îÄ‚îÄ‚îÄ Format DD/MM/YYYY ou DD-MM-YYYY ou DD.MM.YYYY ‚îÄ‚îÄ‚îÄ
        const match = cleaned.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{2,4})$/);
        if (match) {
            let [, day, month, year] = match;
            
            // G√©rer les ann√©es sur 2 chiffres
            if (year.length === 2) {
                year = (parseInt(year) > 50 ? '19' : '20') + year;
            }
            
            // V√©rification de validit√©
            const date = new Date(year, month - 1, day);
            if (date.getDate() == day && date.getMonth() == month - 1) {
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }
        }
        
        // ‚îÄ‚îÄ‚îÄ Format YYYY-MM-DD (ISO) ‚îÄ‚îÄ‚îÄ
        const isoMatch = cleaned.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (isoMatch) {
            return cleaned;
        }
        
        // ‚îÄ‚îÄ‚îÄ Format MM/DD/YYYY (am√©ricain) ‚îÄ‚îÄ‚îÄ
        const usMatch = cleaned.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})$/);
        if (usMatch) {
            const [, month, day, year] = usMatch;
            const date = new Date(year, month - 1, day);
            if (date.getDate() == day && date.getMonth() == month - 1) {
                return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
            }
        }
        
        // Si aucun format reconnu, retourner la valeur originale ou '-'
        console.warn(`‚ö†Ô∏è Format de date non reconnu: "${value}"`);
        return '-';
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      NETTOYAGE STRING                  ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    cleanString(value) {
        if (!value) return '';
        
        return value
            .trim()
            .replace(/\s+/g, ' ')
            .replace(/^["']|["']$/g, '');
    }
    
    genererReferenceDepuisDesignation(designation) {
        const cleaned = designation
            .toUpperCase()
            .replace(/[^A-Z0-9]/g, '')
            .substring(0, 10);
        
        const random = Math.random().toString(36).substring(2, 5).toUpperCase();
        return `AUTO-${cleaned}-${random}`;
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      EXTRACTION NUM√âRO ACM             ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    extractNumeroACM(filename) {
        const nameWithoutExt = filename.replace(/\.[^/.]+$/, '');
        
        // ‚îÄ‚îÄ‚îÄ Si le nom est enti√®rement num√©rique ‚îÄ‚îÄ‚îÄ
        if (/^\d+$/.test(nameWithoutExt)) {
            return nameWithoutExt;
        }
        
        // ‚îÄ‚îÄ‚îÄ Chercher un pattern num√©rique long ‚îÄ‚îÄ‚îÄ
        const match = filename.match(/(\d{8,})/);
        if (match) {
            return match[1];
        }
        
        console.warn('‚ö†Ô∏è Impossible d\'extraire le num√©ro ACM du fichier:', filename);
        return null;
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      LECTURE AVEC D√âTECTION ENCODING   ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    async readFileWithEncoding(file) {
        const encodings = ['utf-8', 'windows-1252', 'iso-8859-1'];
        
        for (const encoding of encodings) {
            try {
                const text = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file, encoding);
                });
                
                // ‚îÄ‚îÄ‚îÄ V√©rifier caract√®res de remplacement ‚îÄ‚îÄ‚îÄ
                if (!text.includes('ÔøΩ') && !text.includes('√Ø¬ø¬Ω')) {
                    console.log(`‚úÖ Encoding d√©tect√©: ${encoding}`);
                    return text;
                }
            } catch (error) {
                continue;
            }
        }
        
        // ‚îÄ‚îÄ‚îÄ Par d√©faut UTF-8 ‚îÄ‚îÄ‚îÄ
        return await file.text();
    }
    
    // ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    // ‚îÇ      CALCUL STATISTIQUES               ‚îÇ
    // ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    
    calculateStats(articles) {
        const stats = {
            total: articles.length,
            quantiteTotale: 0,
            valeurStock: 0,
            valeurAchat: 0,
            margeGlobale: 0,
            articlesEnRupture: 0,
            articlesStockBas: 0,
            parStatut: {},
            parMarque: {}
        };
        
        articles.forEach(article => {
            const qte = article.quantite || 0;
            const pa = article.prixAchat || 0;
            const pv = article.prixVente || 0;
            
            stats.quantiteTotale += qte;
            stats.valeurStock += qte * pv;
            stats.valeurAchat += qte * pa;
            
            // ‚îÄ‚îÄ‚îÄ √âtats stock ‚îÄ‚îÄ‚îÄ
            if (qte <= 0) {
                stats.articlesEnRupture++;
            } else if (qte <= (article.quantiteMin || 0)) {
                stats.articlesStockBas++;
            }
            
            // ‚îÄ‚îÄ‚îÄ Par statut ‚îÄ‚îÄ‚îÄ
            const statut = article.statut || 'STO';
            if (!stats.parStatut[statut]) {
                stats.parStatut[statut] = {
                    nombre: 0,
                    quantite: 0
                };
            }
            stats.parStatut[statut].nombre++;
            stats.parStatut[statut].quantite += qte;
            
            // ‚îÄ‚îÄ‚îÄ Par marque ‚îÄ‚îÄ‚îÄ
            if (article.marque) {
                const marque = article.marque;
                if (!stats.parMarque[marque]) {
                    stats.parMarque[marque] = {
                        nombre: 0,
                        quantite: 0
                    };
                }
                stats.parMarque[marque].nombre++;
                stats.parMarque[marque].quantite += qte;
            }
        });
        
        // ‚îÄ‚îÄ‚îÄ Marge globale ‚îÄ‚îÄ‚îÄ
        stats.margeGlobale = stats.valeurStock - stats.valeurAchat;
        
        return stats;
    }
}

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë      SECTION 3: EXPORT SINGLETON       ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

const service = new StockProduitUploadService();
export default service;