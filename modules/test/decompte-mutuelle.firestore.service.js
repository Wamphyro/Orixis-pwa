// ========================================
// DECOMPTE-MUTUELLE.FIRESTORE.SERVICE.JS - üî• SERVICE FIRESTORE
// Chemin: modules/test/decompte-mutuelle.firestore.service.js
//
// DESCRIPTION:
// Service CRUD pour les d√©comptes mutuelles dans Firestore
// G√®re la cr√©ation, lecture, mise √† jour et suppression
//
// FONCTIONS PUBLIQUES:
// - creerDecompte(data) : Cr√©er un nouveau d√©compte
// - getDecomptes(filtres) : R√©cup√©rer les d√©comptes
// - getDecompteById(id) : R√©cup√©rer un d√©compte
// - updateDecompte(id, updates) : Mettre √† jour
// - changerStatut(id, statut, options) : Changer le statut
// - supprimerDecompte(id, infos) : Soft delete
// ========================================

import { db } from '../../src/services/firebase.service.js';
import { DECOMPTE_TEMPLATE, createNewDecompte, createHistoriqueEntry } from './decompte-mutuelle.template.js';

// ========================================
// CONFIGURATION
// ========================================

const CONFIG = {
    COLLECTION_NAME: 'decomptes_mutuelles',
    
    // Statuts workflow
    STATUTS: {
        NOUVEAU: 'nouveau',
        TRAITEMENT_IA: 'traitement_ia',
        TRAITEMENT_EFFECTUE: 'traitement_effectue',
        TRAITEMENT_MANUEL: 'traitement_manuel',
        RAPPROCHEMENT_BANCAIRE: 'rapprochement_bancaire',
        SUPPRIME: 'supprime'
    },
    
    // Infos statuts pour UI
    STATUTS_INFO: {
        nouveau: {
            label: 'Nouveau',
            suivant: 'traitement_ia'
        },
        traitement_ia: {
            label: 'Traitement IA',
            suivant: 'traitement_effectue'
        },
        traitement_effectue: {
            label: 'Trait√©',
            suivant: 'rapprochement_bancaire'
        },
        traitement_manuel: {
            label: 'Traitement manuel',
            suivant: 'rapprochement_bancaire'
        },
        rapprochement_bancaire: {
            label: 'Rapproch√©',
            suivant: null
        },
        supprime: {
            label: 'Supprim√©',
            suivant: null
        }
    }
};

// ========================================
// CLASSE DU SERVICE
// ========================================

export class DecompteFirestoreService {
    
    /**
     * Cr√©er un nouveau d√©compte
     * @param {Object} data - Donn√©es initiales (documents upload√©s)
     * @returns {Promise<string>} ID du d√©compte cr√©√©
     */
    static async creerDecompte(data) {
        try {
            const { collection, addDoc, serverTimestamp } = await import(
                'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
            );
            
            // G√©n√©rer le num√©ro de d√©compte
            const numeroDecompte = await this.genererNumeroDecompte();
            
            // R√©cup√©rer les infos utilisateur
            const userInfo = this.getUserInfo();
            
            console.log('üîç DEBUG cr√©ation d√©compte:', { userInfo, data });
            
            // Cloner le template pour garantir la structure
            const decompteData = createNewDecompte();
            
            // Remplir les donn√©es du template
            decompteData.numeroDecompte = numeroDecompte;
            decompteData.typeDecompte = 'individuel'; // Par d√©faut, sera d√©termin√© par l'IA
            
            // Organisation
            decompteData.societe = userInfo.societe || 'NON_DEFINI';
            decompteData.codeMagasin = userInfo.magasin;
            decompteData.magasinUploadeur = userInfo.magasin;
            
            // Documents upload√©s
            decompteData.documents = data.documents || [];
            
            // Dates - utiliser serverTimestamp pour la cr√©ation
            decompteData.dates.creation = serverTimestamp();
            
            // Intervenants
            decompteData.intervenants.creePar = {
                id: userInfo.id,
                nom: userInfo.nom,
                prenom: userInfo.prenom,
                role: userInfo.role || 'technicien'
            };
            
            // Historique initial
            decompteData.historique = [
                createHistoriqueEntry(
                    'creation',
                    `${data.documents.length} document(s) upload√©(s)`,
                    decompteData.intervenants.creePar
                )
            ];
            
            // Statut initial
            decompteData.statut = CONFIG.STATUTS.NOUVEAU;
            
            // Cr√©er dans Firestore
            const docRef = await addDoc(collection(db, CONFIG.COLLECTION_NAME), decompteData);
            
            console.log('‚úÖ D√©compte cr√©√©:', numeroDecompte, 'ID:', docRef.id);
            
            return docRef.id;
            
        } catch (error) {
            console.error('‚ùå Erreur cr√©ation d√©compte:', error);
            throw new Error(`Erreur lors de la cr√©ation: ${error.message}`);
        }
    }
    
    /**
     * R√©cup√©rer les d√©comptes avec filtres
     * @param {Object} filtres - Filtres optionnels
     * @returns {Promise<Array>} Liste des d√©comptes
     */
    static async getDecomptes(filtres = {}) {
        try {
            const { collection, query, where, orderBy, limit, getDocs } = await import(
                'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
            );
            
            let q = collection(db, CONFIG.COLLECTION_NAME);
            const constraints = [];
            
            // Construire la requ√™te avec les filtres
            if (filtres.societe) {
                constraints.push(where('societe', '==', filtres.societe));
            }
            
            if (filtres.statut) {
                constraints.push(where('statut', '==', filtres.statut));
            }
            
            if (filtres.magasin) {
                constraints.push(where('codeMagasin', '==', filtres.magasin));
            }
            
            if (filtres.mutuelle) {
                constraints.push(where('mutuelle', '==', filtres.mutuelle));
            }
            
            // Tri par d√©faut : plus r√©cent en premier
            constraints.push(orderBy('dates.creation', 'desc'));
            
            if (filtres.limite) {
                constraints.push(limit(filtres.limite));
            }
            
            // Appliquer les contraintes
            if (constraints.length > 0) {
                q = query(q, ...constraints);
            }
            
            // Ex√©cuter la requ√™te
            const snapshot = await getDocs(q);
            
            const decomptes = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                decomptes.push({
                    id: doc.id,
                    ...data
                });
            });
            
            console.log(`üìä ${decomptes.length} d√©comptes trouv√©s`);
            return decomptes;
            
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration d√©comptes:', error);
            return [];
        }
    }
    
    /**
     * R√©cup√©rer un d√©compte par ID
     * @param {string} id - ID du d√©compte
     * @returns {Promise<Object|null>} Le d√©compte ou null
     */
    static async getDecompteById(id) {
        try {
            const { doc, getDoc } = await import(
                'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
            );
            
            const docRef = doc(db, CONFIG.COLLECTION_NAME, id);
            const docSnap = await getDoc(docRef);
            
            if (docSnap.exists()) {
                return {
                    id: docSnap.id,
                    ...docSnap.data()
                };
            }
            
            console.warn(`‚ö†Ô∏è D√©compte ${id} introuvable`);
            return null;
            
        } catch (error) {
            console.error('‚ùå Erreur r√©cup√©ration d√©compte:', error);
            return null;
        }
    }
    
    /**
     * Mettre √† jour un d√©compte
     * @param {string} id - ID du d√©compte
     * @param {Object} updates - Mises √† jour
     * @returns {Promise<void>}
     */
    static async updateDecompte(id, updates) {
        const { doc, updateDoc, arrayUnion } = await import(
            'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
        );
        
        // Ajouter √† l'historique
        const userInfo = this.getUserInfo();
        const updatesAvecHistorique = {
            ...updates,
            historique: arrayUnion(
                createHistoriqueEntry(
                    'mise_a_jour',
                    'D√©compte mis √† jour',
                    {
                        id: userInfo.id,
                        nom: userInfo.nom,
                        prenom: userInfo.prenom,
                        role: userInfo.role
                    }
                )
            )
        };
        
        await updateDoc(doc(db, CONFIG.COLLECTION_NAME, id), updatesAvecHistorique);
        console.log('‚úÖ D√©compte mis √† jour:', id);
    }
    
/**
 * Ajouter les donn√©es extraites par l'IA
 * @param {string} decompteId - ID du d√©compte
 * @param {Object} donnees - Donn√©es extraites
 */
static async ajouterDonneesExtraites(decompteId, donneesExtraites) {
    try {
        // ‚úÖ IMPORTER doc, updateDoc ET arrayUnion
        const { doc, updateDoc, arrayUnion } = await import(
            'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
        );
        
        const decompteRef = doc(db, 'decomptes_mutuelles', decompteId);
        
        // Pr√©parer les donn√©es √† mettre √† jour
        const updateData = {
            ...donneesExtraites,
            statut: 'traitement_effectue',
            'dates.traitementEffectue': new Date(),
            'dates.transmissionIA': new Date(),
            'intervenants.traitePar': {
                id: 'system_ia',
                nom: 'SYSTEM',
                prenom: 'IA',
                role: 'system'
            },
            // ‚úÖ AJOUTER L'HISTORIQUE DIRECTEMENT ICI
            historique: arrayUnion({
                action: 'extraction_ia',
                date: new Date(),
                details: 'Donn√©es extraites par IA',
                timestamp: Date.now(),
                utilisateur: {
                    id: 'system_ia',
                    nom: 'SYSTEM',
                    prenom: 'IA',
                    role: 'system'
                }
            })
        };
        
        // SI c'est un d√©compte group√©, s'assurer que les clients sont au niveau racine
        if (donneesExtraites.typeDecompte === 'groupe' && donneesExtraites.extractionIA?.donneesBrutes?.clients) {
            updateData.clients = donneesExtraites.extractionIA.donneesBrutes.clients.map(c => ({
                nom: c.ClientNom || null,
                prenom: c.ClientPrenom || null,
                numeroSecuriteSociale: c.NumeroSecuriteSociale || null,
                numeroAdherent: c.NumeroAdherent || null,
                montantRemboursement: c.Montant || 0
            }));
        }
        
        await updateDoc(decompteRef, updateData);
        
        // ‚ùå LIGNE SUPPRIM√âE : await this.ajouterHistorique(...)
        
        console.log('‚úÖ Donn√©es extraites ajout√©es au d√©compte');
        return true;
        
    } catch (error) {
        console.error('‚ùå Erreur ajout donn√©es extraites:', error);
        throw error;
    }
}
    
    /**
     * Changer le statut d'un d√©compte
     * @param {string} decompteId - ID du d√©compte
     * @param {string} nouveauStatut - Nouveau statut
     * @param {Object} options - Options (motif, etc.)
     * @returns {Promise<void>}
     */
    static async changerStatut(decompteId, nouveauStatut, options = {}) {
        const { serverTimestamp, arrayUnion } = await import(
            'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
        );
        
        // R√©cup√©rer le d√©compte actuel
        const decompte = await this.getDecompteById(decompteId);
        if (!decompte) {
            throw new Error('D√©compte introuvable');
        }
        
        // V√©rifier que le changement est valide
        const statutActuel = decompte.statut;
        const statutSuivantAttendu = CONFIG.STATUTS_INFO[statutActuel]?.suivant;
        
        // Autoriser le passage vers traitement manuel depuis traitement_ia
        const isPassageManuel = statutActuel === CONFIG.STATUTS.TRAITEMENT_IA && 
                                nouveauStatut === CONFIG.STATUTS.TRAITEMENT_MANUEL;
        
        if (nouveauStatut !== CONFIG.STATUTS.SUPPRIME && 
            nouveauStatut !== statutSuivantAttendu && 
            !isPassageManuel) {
            throw new Error(`Passage de ${statutActuel} √† ${nouveauStatut} non autoris√©`);
        }
        
        // Pr√©parer les mises √† jour
        const userInfo = this.getUserInfo();
        const updates = {
            statut: nouveauStatut,
            historique: arrayUnion(
                createHistoriqueEntry(
                    `statut_${nouveauStatut}`,
                    `Statut chang√© en ${CONFIG.STATUTS_INFO[nouveauStatut].label}`,
                    {
                        id: userInfo.id,
                        nom: userInfo.nom,
                        prenom: userInfo.prenom,
                        role: userInfo.role
                    }
                )
            )
        };
        
        // Mises √† jour sp√©cifiques selon le statut
        switch (nouveauStatut) {
            case CONFIG.STATUTS.TRAITEMENT_IA:
                updates['dates.transmissionIA'] = serverTimestamp();
                break;
                
            case CONFIG.STATUTS.TRAITEMENT_EFFECTUE:
                updates['dates.traitementEffectue'] = serverTimestamp();
                updates['intervenants.traitePar'] = userInfo;
                break;
                
            case CONFIG.STATUTS.TRAITEMENT_MANUEL:
                updates['dates.traitementManuel'] = serverTimestamp();
                updates['intervenants.traitePar'] = userInfo;
                if (options.motif) {
                    updates.motifTraitementManuel = options.motif;
                }
                break;
                
            case CONFIG.STATUTS.RAPPROCHEMENT_BANCAIRE:
                updates['dates.rapprochementBancaire'] = serverTimestamp();
                updates['intervenants.rapprochePar'] = userInfo;
                break;
                
            case CONFIG.STATUTS.SUPPRIME:
                updates.suppression = {
                    date: serverTimestamp(),
                    par: userInfo,
                    motif: options.motif || 'Non sp√©cifi√©'
                };
                break;
        }
        
        // Effectuer la mise √† jour
        await this.updateDecompte(decompteId, updates);
        
        console.log(`‚úÖ Statut chang√©: ${statutActuel} ‚Üí ${nouveauStatut}`);
    }
    
    /**
     * Supprimer un d√©compte (soft delete)
     * @param {string} decompteId - ID du d√©compte
     * @param {Object} infos - Informations de suppression
     * @returns {Promise<void>}
     */
    static async supprimerDecompte(decompteId, infos = {}) {
        try {
            await this.changerStatut(decompteId, CONFIG.STATUTS.SUPPRIME, {
                motif: infos.motif || 'Suppression manuelle'
            });
            
            console.log('‚úÖ D√©compte supprim√© (soft delete):', decompteId);
            
        } catch (error) {
            console.error('‚ùå Erreur suppression d√©compte:', error);
            throw new Error('Impossible de supprimer le d√©compte : ' + error.message);
        }
    }
    
    /**
     * Obtenir les statistiques
     * @returns {Promise<Object>} Statistiques
     */
    static async getStatistiques() {
        const decomptes = await this.getDecomptes({ limite: 1000 });
        
        const stats = {
            total: 0,
            parStatut: {},
            parMutuelle: {},
            montantTotal: 0,
            montantMoyen: 0
        };
        
        decomptes.forEach(decompte => {
            // Exclure les d√©comptes supprim√©s des stats
            if (decompte.statut === CONFIG.STATUTS.SUPPRIME) {
                return;
            }
            
            stats.total++;
            
            // Par statut
            stats.parStatut[decompte.statut] = (stats.parStatut[decompte.statut] || 0) + 1;
            
            // Par mutuelle
            if (decompte.mutuelle) {
                stats.parMutuelle[decompte.mutuelle] = (stats.parMutuelle[decompte.mutuelle] || 0) + 1;
            }
            
            // Montants
            stats.montantTotal += decompte.montantVirement || 0;
        });
        
        // Montant moyen
        stats.montantMoyen = stats.total > 0 ? stats.montantTotal / stats.total : 0;
        
        console.log('üìà Statistiques calcul√©es:', stats);
        return stats;
    }
    
    /**
     * Charger les magasins depuis Firestore
     * @returns {Promise<Array>} Liste des magasins
     */
    static async chargerMagasins() {
        const { collection, getDocs, query, where } = await import(
            'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
        );
        
        // Cr√©er une requ√™te pour r√©cup√©rer TOUS les magasins actifs
        const magasinsRef = collection(db, 'magasins');
        const q = query(magasinsRef, where('actif', '==', true));
        
        // R√©cup√©rer TOUS les documents
        const magasinsSnapshot = await getDocs(q);
        const magasinsArray = [];
        
        console.log(`üìä ${magasinsSnapshot.size} magasins trouv√©s dans Firestore`);
        
        magasinsSnapshot.forEach((doc) => {
            const data = doc.data();
            
            magasinsArray.push({
                FINESS: data.numeroFINESS || '',
                'CODE MAGASIN': data.code || doc.id,
                SOCIETE: data.societe?.raisonSociale || '',
                ADRESSE: `${data.adresse?.rue || ''} ${data.adresse?.codePostal || ''} ${data.adresse?.ville || ''}`.trim(),
                VILLE: data.adresse?.ville || ''
            });
        });
        
        // Stocker en localStorage pour utilisation ult√©rieure
        localStorage.setItem('orixis_magasins', JSON.stringify(
            magasinsArray.reduce((acc, mag) => {
                acc[mag['CODE MAGASIN']] = {
                    numeroFINESS: mag.FINESS,
                    societe: { raisonSociale: mag.SOCIETE },
                    adresse: { ville: mag.VILLE }
                };
                return acc;
            }, {})
        ));
        
        return magasinsArray;
    }
    
    // ========================================
    // M√âTHODES PRIV√âES
    // ========================================
    
    /**
     * G√©n√©rer un num√©ro de d√©compte unique
     * Format: DEC-AAAAMMJJ-XXXX
     */
    static async genererNumeroDecompte() {
        try {
            const { collection, query, where, orderBy, limit, getDocs } = await import(
                'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js'
            );
            
            const date = new Date();
            const annee = date.getFullYear();
            const mois = String(date.getMonth() + 1).padStart(2, '0');
            const jour = String(date.getDate()).padStart(2, '0');
            const dateStr = `${annee}${mois}${jour}`;
            const prefix = `DEC-${dateStr}`;
            
            // Chercher le dernier num√©ro du jour
            const q = query(
                collection(db, CONFIG.COLLECTION_NAME),
                where('numeroDecompte', '>=', `${prefix}-0000`),
                where('numeroDecompte', '<=', `${prefix}-9999`),
                orderBy('numeroDecompte', 'desc'),
                limit(1)
            );
            
            const snapshot = await getDocs(q);
            
            let nextNumber = 1;
            if (!snapshot.empty) {
                const lastDoc = snapshot.docs[0].data();
                const lastNumber = parseInt(lastDoc.numeroDecompte.split('-')[2]);
                nextNumber = lastNumber + 1;
            }
            
            const numero = `${prefix}-${String(nextNumber).padStart(4, '0')}`;
            console.log('üìã Num√©ro g√©n√©r√©:', numero);
            
            return numero;
            
        } catch (error) {
            console.error('‚ö†Ô∏è Erreur g√©n√©ration num√©ro, fallback:', error);
            // Fallback avec timestamp
            return `DEC-${Date.now()}`;
        }
    }
    
    /**
     * Obtenir les infos utilisateur
     * @private
     */
    static getUserInfo() {
        const auth = JSON.parse(localStorage.getItem('sav_auth') || '{}');
        return {
            id: auth.collaborateur?.id || 'unknown',
            nom: auth.collaborateur?.nom || 'Inconnu',
            prenom: auth.collaborateur?.prenom || '',
            role: auth.collaborateur?.role || 'technicien',
            name: `${auth.collaborateur?.prenom || ''} ${auth.collaborateur?.nom || ''}`.trim() || 'Inconnu',
            magasin: auth.magasin || auth.collaborateur?.magasin || 'XXX',
            societe: auth.raisonSociale || auth.societe || 'NON_DEFINI'
        };
    }
}

// ========================================
// EXPORT
// ========================================

export default {
    creerDecompte: DecompteFirestoreService.creerDecompte.bind(DecompteFirestoreService),
    getDecomptes: DecompteFirestoreService.getDecomptes.bind(DecompteFirestoreService),
    getDecompteById: DecompteFirestoreService.getDecompteById.bind(DecompteFirestoreService),
    updateDecompte: DecompteFirestoreService.updateDecompte.bind(DecompteFirestoreService),
    ajouterDonneesExtraites: DecompteFirestoreService.ajouterDonneesExtraites.bind(DecompteFirestoreService),
    changerStatut: DecompteFirestoreService.changerStatut.bind(DecompteFirestoreService),
    supprimerDecompte: DecompteFirestoreService.supprimerDecompte.bind(DecompteFirestoreService),
    getStatistiques: DecompteFirestoreService.getStatistiques.bind(DecompteFirestoreService),
    chargerMagasins: DecompteFirestoreService.chargerMagasins.bind(DecompteFirestoreService),
    STATUTS: CONFIG.STATUTS,
    STATUTS_INFO: CONFIG.STATUTS_INFO
};

/* ========================================
   HISTORIQUE
   
   [08/02/2025] - Cr√©ation
   - Service d√©di√© au CRUD Firestore
   - Utilise le template pour garantir la structure
   - Gestion compl√®te du workflow
   - Historique automatique
   ======================================== */