// ========================================
// STATS-CARDS.COMPONENT.JS - Composant de cartes statistiques rÃ©utilisable
// Chemin: src/js/shared/ui/stats-cards.component.js
//
// DESCRIPTION:
// Composant indÃ©pendant pour afficher des cartes de statistiques
// Utilisable dans n'importe quel contexte avec diffÃ©rentes configurations
//
// API PUBLIQUE:
// - constructor(config)
// - updateCard(cardId, value)
// - updateAll(values)
// - setEnabled(cardId, enabled)
// - destroy()
//
// CALLBACKS DISPONIBLES:
// - onClick: (cardId, cardData) => void
// - onHover: (cardId, cardData) => void
// - onUpdate: (cardId, oldValue, newValue) => void
//
// EXEMPLE:
// const stats = new StatsCards({
//     container: '.stats-container',
//     cards: [
//         { id: 'total', label: 'Total', value: 0, color: 'primary' }
//     ],
//     onClick: (cardId) => console.log('Clicked:', cardId)
// });
// ========================================

import { generateId } from '../index.js';

export class StatsCards {
    constructor(config) {
        this.id = generateId('stats');
        
        // Configuration par dÃ©faut
        this.config = {
            container: null,
            cards: [],
            animated: true,        // Animation des nombres
            clickable: true,       // Cartes cliquables
            hoverable: true,       // Effet au survol
            numberFormat: 'default', // Format des nombres
            onClick: null,         // Callback au clic
            onHover: null,         // Callback au survol
            onUpdate: null,        // Callback Ã  la mise Ã  jour
            theme: 'default',      // ThÃ¨me visuel
            ...config
        };
        
        // Ã‰tat interne
        this.state = {
            values: {},
            enabled: {}
        };
        
        // Ã‰lÃ©ments DOM
        this.elements = {
            container: null,
            cards: {}
        };
        
        // Initialiser
        this.init();
    }
    
    // ========================================
    // INITIALISATION ET CONFIGURATION
    // ========================================
    
    init() {
        // Charger les styles
        this.loadStyles();
        
        // VÃ©rifier le container
        if (typeof this.config.container === 'string') {
            this.elements.container = document.querySelector(this.config.container);
        } else {
            this.elements.container = this.config.container;
        }
        
        if (!this.elements.container) {
            console.error('StatsCards: Container non trouvÃ©');
            return;
        }
        
        // Initialiser l'Ã©tat
        this.initState();
        
        // CrÃ©er le DOM
        this.render();
        
        // Attacher les Ã©vÃ©nements
        this.attachEvents();
        
        // ðŸ†• ANTI-FOUC : Marquer comme chargÃ© aprÃ¨s un court dÃ©lai
        setTimeout(() => {
            const wrapper = this.elements.container.querySelector('.stats-cards-wrapper');
            if (wrapper) {
                wrapper.classList.add('loaded');
            }
        }, 150); // DÃ©lai pour s'assurer que le CSS est chargÃ©
        
        console.log('âœ… StatsCards initialisÃ©');
    }
    
    loadStyles() {
        const styleId = 'stats-cards-styles';
        
        if (!document.getElementById(styleId)) {
            const link = document.createElement('link');
            link.id = styleId;
            link.rel = 'stylesheet';
            link.href = '../src/css/shared/ui/stats-cards.css';
            document.head.appendChild(link);
            
            // ðŸ†• ANTI-FOUC : Attendre que le CSS soit chargÃ©
            link.onload = () => {
                console.log('ðŸ“¦ CSS StatsCards chargÃ©');
            };
        }
    }
    
    initState() {
        // Initialiser les valeurs et Ã©tats
        this.config.cards.forEach(card => {
            this.state.values[card.id] = card.value || 0;
            this.state.enabled[card.id] = card.enabled !== false;
        });
    }
    
    // ========================================
    // RENDU ET DOM
    // ========================================
    
    render() {
        // CrÃ©er le wrapper
        const wrapper = document.createElement('div');
        wrapper.className = `stats-cards-wrapper theme-${this.config.theme}`;
        wrapper.id = this.id;
        
        // ðŸ†• ANTI-FOUC : Ajouter les styles inline initiaux
        wrapper.style.opacity = '0';
        wrapper.style.transition = 'opacity 0.3s ease';
        
        // CrÃ©er chaque carte
        this.config.cards.forEach(cardConfig => {
            const card = this.createCard(cardConfig);
            if (card) {
                wrapper.appendChild(card);
                this.elements.cards[cardConfig.id] = card;
            }
        });
        
        // Vider et remplir le container
        this.elements.container.innerHTML = '';
        this.elements.container.appendChild(wrapper);
    }
    
    createCard(config) {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.dataset.cardId = config.id;
        
        // Ajouter les classes selon la config
        if (config.color) {
            card.classList.add(`stat-card-${config.color}`);
        }
        
        if (this.config.clickable && config.clickable !== false) {
            card.classList.add('clickable');
        }
        
        if (this.config.hoverable && config.hoverable !== false) {
            card.classList.add('hoverable');
        }
        
        if (!this.state.enabled[config.id]) {
            card.classList.add('disabled');
        }
        
        // ðŸ†• AMÃ‰LIORATION : Valeur d'affichage par dÃ©faut
        const displayValue = config.value !== undefined ? config.value : '-';
        
        // IcÃ´ne optionnelle
        const iconHtml = config.icon ? `<div class="stat-icon">${config.icon}</div>` : '';
        
        // Structure interne
        card.innerHTML = `
            ${iconHtml}
            <div class="stat-content">
                <div class="stat-number" data-value="${config.value || 0}">
                    ${this.formatNumber(displayValue)}
                </div>
                <div class="stat-label">${config.label}</div>
                ${config.sublabel ? `<div class="stat-sublabel">${config.sublabel}</div>` : ''}
            </div>
            ${config.trend ? this.createTrend(config.trend) : ''}
        `;
        
        return card;
    }
    
    createTrend(trend) {
        const direction = trend.value > 0 ? 'up' : trend.value < 0 ? 'down' : 'neutral';
        const icon = direction === 'up' ? 'â†‘' : direction === 'down' ? 'â†“' : 'â†’';
        const color = direction === 'up' ? 'success' : direction === 'down' ? 'danger' : 'neutral';
        
        return `
            <div class="stat-trend trend-${color}">
                <span class="trend-icon">${icon}</span>
                <span class="trend-value">${Math.abs(trend.value)}${trend.suffix || '%'}</span>
                ${trend.label ? `<span class="trend-label">${trend.label}</span>` : ''}
            </div>
        `;
    }
    
    formatNumber(value) {
        // ðŸ†• AMÃ‰LIORATION : GÃ©rer les valeurs non numÃ©riques
        if (value === '-' || value === null || value === undefined) {
            return '-';
        }
        
        // Formatage selon le type
        switch (this.config.numberFormat) {
            case 'currency':
                return new Intl.NumberFormat('fr-FR', {
                    style: 'currency',
                    currency: 'EUR'
                }).format(value);
                
            case 'percent':
                return `${value}%`;
                
            case 'compact':
                return new Intl.NumberFormat('fr-FR', {
                    notation: 'compact',
                    maximumFractionDigits: 1
                }).format(value);
                
            default:
                return new Intl.NumberFormat('fr-FR').format(value);
        }
    }
    
    // ========================================
    // GESTION DES Ã‰VÃ‰NEMENTS
    // ========================================
    
    attachEvents() {
        Object.entries(this.elements.cards).forEach(([cardId, cardElement]) => {
            const config = this.config.cards.find(c => c.id === cardId);
            
            // Ã‰vÃ©nement click
            if (this.config.clickable && config.clickable !== false) {
                cardElement.addEventListener('click', () => {
                    this.handleCardClick(cardId);
                });
            }
            
            // Ã‰vÃ©nement hover
            if (this.config.hoverable && config.hoverable !== false && this.config.onHover) {
                cardElement.addEventListener('mouseenter', () => {
                    this.handleCardHover(cardId);
                });
            }
        });
    }
    
    handleCardClick(cardId) {
        // VÃ©rifier si la carte est activÃ©e
        if (!this.state.enabled[cardId]) return;
        
        // Animation de clic
        const card = this.elements.cards[cardId];
        card.classList.add('clicked');
        setTimeout(() => card.classList.remove('clicked'), 300);
        
        // Callback
        if (this.config.onClick) {
            const cardData = this.getCardData(cardId);
            this.config.onClick(cardId, cardData);
        }
    }
    
    handleCardHover(cardId) {
        if (!this.state.enabled[cardId]) return;
        
        if (this.config.onHover) {
            const cardData = this.getCardData(cardId);
            this.config.onHover(cardId, cardData);
        }
    }
    
    // ========================================
    // API PUBLIQUE
    // ========================================
    
    /**
     * Met Ã  jour la valeur d'une carte
     * @param {string} cardId - ID de la carte
     * @param {number} value - Nouvelle valeur
     * @param {boolean} animate - Animer la transition
     */
    updateCard(cardId, value, animate = true) {
        if (!this.elements.cards[cardId]) {
            console.warn(`StatsCards: Carte "${cardId}" non trouvÃ©e`);
            return;
        }
        
        const oldValue = this.state.values[cardId];
        this.state.values[cardId] = value;
        
        // Mettre Ã  jour le DOM
        const numberElement = this.elements.cards[cardId].querySelector('.stat-number');
        if (numberElement) {
            if (this.config.animated && animate) {
                this.animateNumber(numberElement, oldValue, value);
            } else {
                numberElement.textContent = this.formatNumber(value);
                numberElement.dataset.value = value;
            }
        }
        
        // Callback
        if (this.config.onUpdate) {
            this.config.onUpdate(cardId, oldValue, value);
        }
    }
    
    /**
     * Met Ã  jour plusieurs cartes en une fois
     * @param {Object} values - Objet {cardId: value}
     * @param {boolean} animate - Animer les transitions
     */
    updateAll(values, animate = true) {
        Object.entries(values).forEach(([cardId, value]) => {
            this.updateCard(cardId, value, animate);
        });
    }
    
    /**
     * Active/dÃ©sactive une carte
     * @param {string} cardId - ID de la carte
     * @param {boolean} enabled - Ã‰tat activÃ©/dÃ©sactivÃ©
     */
    setEnabled(cardId, enabled) {
        if (!this.elements.cards[cardId]) return;
        
        this.state.enabled[cardId] = enabled;
        
        const card = this.elements.cards[cardId];
        if (enabled) {
            card.classList.remove('disabled');
        } else {
            card.classList.add('disabled');
        }
    }
    
    /**
     * ðŸ†• NOUVELLE MÃ‰THODE : Afficher le composant une fois chargÃ©
     */
    show() {
        const wrapper = this.elements.container.querySelector('.stats-cards-wrapper');
        if (wrapper) {
            wrapper.style.opacity = '1';
            wrapper.classList.add('loaded');
        }
    }
    
    /**
     * ðŸ†• NOUVELLE MÃ‰THODE : Masquer le composant
     */
    hide() {
        const wrapper = this.elements.container.querySelector('.stats-cards-wrapper');
        if (wrapper) {
            wrapper.style.opacity = '0';
            wrapper.classList.remove('loaded');
        }
    }
    
    /**
     * RÃ©cupÃ¨re les donnÃ©es d'une carte
     * @param {string} cardId - ID de la carte
     * @returns {Object} DonnÃ©es de la carte
     */
    getCardData(cardId) {
        const config = this.config.cards.find(c => c.id === cardId);
        return {
            ...config,
            value: this.state.values[cardId],
            enabled: this.state.enabled[cardId]
        };
    }
    
    /**
     * DÃ©truit le composant
     */
    destroy() {
        // Vider le container
        if (this.elements.container) {
            this.elements.container.innerHTML = '';
        }
        
        // RÃ©initialiser
        this.state = { values: {}, enabled: {} };
        this.elements = { container: null, cards: {} };
    }
    
    // ========================================
    // MÃ‰THODES PRIVÃ‰ES
    // ========================================
    
    animateNumber(element, from, to) {
        const duration = 1000; // 1 seconde
        const steps = 30;
        const stepDuration = duration / steps;
        const increment = (to - from) / steps;
        
        let current = from;
        let step = 0;
        
        const timer = setInterval(() => {
            step++;
            current += increment;
            
            if (step >= steps) {
                current = to;
                clearInterval(timer);
            }
            
            element.textContent = this.formatNumber(Math.round(current));
            element.dataset.value = current;
        }, stepDuration);
    }
}

/* ========================================
   HISTORIQUE DES DIFFICULTÃ‰S
   
   [29/01/2025] - CrÃ©ation initiale
   - Composant crÃ©Ã© en suivant le pattern IoC
   - Animation des nombres optionnelle
   - Support de diffÃ©rents formats de nombres
   
   [30/01/2025] - Correction FOUC
   - Ajout de l'opacitÃ© initiale Ã  0
   - DÃ©lai avant affichage (150ms)
   - MÃ©thodes show()/hide() ajoutÃ©es
   - Gestion des valeurs '-' par dÃ©faut
   
   NOTES POUR REPRISES FUTURES:
   - Le composant charge automatiquement son CSS
   - Les callbacks sont optionnels
   - L'animation peut Ãªtre dÃ©sactivÃ©e globalement ou par mise Ã  jour
   - Anti-FOUC intÃ©grÃ© avec transition d'opacitÃ©
   ======================================== */